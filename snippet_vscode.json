{
  "r3yohei_01bfs": {
    "prefix": "r3yohei_01bfs",
    "body": [
      "/// 隣接リスト表現に対する01BFS",
      "/// 辺のコストが0or1のグラフに使用する",
      "fn zero_one_bfs(edges: &Vec<Vec<(usize, i64)>>, s: usize) {",
      "    //! 辺のコストが1ならdequeの右端，0なら左端を繰り返す",
      "    //! dequeの中身の頂点の暫定最短距離が常に(1,1,2,3,4,4,..)",
      "    //! のように，左と同じかそれ+1であるように並ぶ",
      "    //! 暫定距離が短いものからpop_frontしたいのでこうなる",
      "    //! ダイクストラでheapqを使うのと同じ気持ちだが，dequeなので計算量がO(V+ElogV)からO(V+E)に落ちる",
      "    let n = edges.len();",
      "    const INF: i64 = 1_000_000_000;",
      "    let mut dist = vec![INF; n];",
      "    dist[s] = 0;",
      "    let mut deque = VecDeque::new();",
      "    deque.push_back(s);",
      "    while let Some(frm) = deque.pop_front() {",
      "        for &(to, cost) in &edges[frm] {",
      "            let d = dist[frm] + cost;",
      "            if d < dist[to] {",
      "                dist[to] = d;",
      "                if cost == 1 {",
      "                    deque.push_back(to);",
      "                } else {",
      "                    deque.push_front(to);",
      "                }",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "r3yohei_01bfs_grid": {
    "prefix": "r3yohei_01bfs_grid",
    "body": [
      "/// 二次元グリッド上での，01BFS",
      "/// 例えば方向を状態に持てば壁にぶつかるまでの間好きなだけ方向転換できる",
      "fn zero_one_bfs(c: &Vec<Vec<char>>, s_x: usize, s_y: usize) -> Vec<Vec<i64>> {",
      "    let h = c.len();",
      "    let w = c[0].len();",
      "    const DIJ: [(usize, usize); 4] = [(!0, !0), (!0, 1), (1, !0), (1, 1)];",
      "    let mut deque = VecDeque::new();",
      "    deque.push_back((s_x, s_y));",
      "    const INF: i64 = 1_000_000_000;",
      "    let mut dist = vec![vec![INF; w]; h];",
      "    dist[s_x][s_y] = 0;",
      "    while let Some((frm_x, frm_y)) = deque.pop_front() {",
      "        let to_cost = dist[frm_x][frm_y] + 1;",
      "        for &(dx, dy) in &DIJ {",
      "            let mut to_x = frm_x.wrapping_add(dx);",
      "            let mut to_y = frm_y.wrapping_add(dy);",
      "            while to_x < h && to_y < w && c[to_x][to_y] == '.' {",
      "                if to_cost < dist[to_x][to_y] {",
      "                    deque.push_back((to_x, to_y));",
      "                    dist[to_x][to_y] = to_cost;",
      "                } else if to_cost > dist[to_x][to_y] {",
      "                    break;",
      "                }",
      "                to_x = to_x.wrapping_add(dx);",
      "                to_y = to_y.wrapping_add(dy);",
      "            }",
      "        }",
      "    }",
      "    dist",
      "}"
    ]
  },
  "r3yohei_ChangeMinMax": {
    "prefix": "r3yohei_ChangeMinMax",
    "body": [
      "/// 最小･最大の交換",
      "/// A.chmax(B)のようにすることで，もしA<BならA=Bとしてtrueを返し，そうでなければAのまま保持してfalseを返す",
      "pub trait ChangeMinMax {",
      "    fn chmin(&mut self, x: Self) -> bool;",
      "    fn chmax(&mut self, x: Self) -> bool;",
      "}",
      "impl<T: PartialOrd> ChangeMinMax for T {",
      "    fn chmin(&mut self, x: Self) -> bool {",
      "        *self > x && {",
      "            *self = x;",
      "            true",
      "        }",
      "    }",
      "    fn chmax(&mut self, x: Self) -> bool {",
      "        *self < x && {",
      "            *self = x;",
      "            true",
      "        }",
      "    }",
      "}"
    ]
  },
  "r3yohei_ModInt": {
    "prefix": "r3yohei_ModInt",
    "body": [
      "#[derive(Debug, Clone, Copy, Default)]",
      "struct ModInt {",
      "    value: usize,",
      "}",
      "impl ModInt {",
      "    const MOD: usize = 998244353;",
      "    fn new(n: usize) -> Self {",
      "        ModInt {",
      "            value: n % Self::MOD,",
      "        }",
      "    }",
      "    fn zero() -> Self {",
      "        ModInt { value: 0 }",
      "    }",
      "    fn one() -> Self {",
      "        ModInt { value: 1 }",
      "    }",
      "    fn value(&self) -> usize {",
      "        self.value",
      "    }",
      "    fn pow(&self, n: usize) -> Self {",
      "        let mut p = *self;",
      "        let mut ret = ModInt::one();",
      "        let mut nn = n;",
      "        while nn > 0 {",
      "            if nn & 1 == 1 {",
      "                ret *= p;",
      "            }",
      "            p *= p;",
      "            nn >>= 1;",
      "        }",
      "        ret",
      "    }",
      "    fn inv(&self) -> Self {",
      "        fn ext_gcd(a: usize, b: usize) -> (isize, isize, usize) {",
      "            if a == 0 {",
      "                return (0, 1, b);",
      "            }",
      "            let (x, y, g) = ext_gcd(b % a, a);",
      "            (y - b as isize / a as isize * x, x, g)",
      "        }",
      "        ModInt::new((ext_gcd(self.value, Self::MOD).0 + Self::MOD as isize) as usize)",
      "    }",
      "}",
      "impl std::ops::Add for ModInt {",
      "    type Output = ModInt;",
      "    fn add(self, other: Self) -> Self {",
      "        ModInt::new(self.value + other.value)",
      "    }",
      "}",
      "impl std::ops::Sub for ModInt {",
      "    type Output = ModInt;",
      "    fn sub(self, other: Self) -> Self {",
      "        ModInt::new(Self::MOD + self.value - other.value)",
      "    }",
      "}",
      "impl std::ops::Mul for ModInt {",
      "    type Output = ModInt;",
      "    fn mul(self, other: Self) -> Self {",
      "        ModInt::new(self.value * other.value)",
      "    }",
      "}",
      "impl std::ops::Div for ModInt {",
      "    type Output = ModInt;",
      "    fn div(self, other: Self) -> Self {",
      "        self * other.inv()",
      "    }",
      "}",
      "impl std::ops::AddAssign for ModInt {",
      "    fn add_assign(&mut self, other: Self) {",
      "        *self = *self + other;",
      "    }",
      "}",
      "impl std::ops::SubAssign for ModInt {",
      "    fn sub_assign(&mut self, other: Self) {",
      "        *self = *self - other;",
      "    }",
      "}",
      "impl std::ops::MulAssign for ModInt {",
      "    fn mul_assign(&mut self, other: Self) {",
      "        *self = *self * other;",
      "    }",
      "}",
      "impl std::ops::DivAssign for ModInt {",
      "    fn div_assign(&mut self, other: Self) {",
      "        *self = *self / other;",
      "    }",
      "}"
    ]
  },
  "r3yohei_TwoPointer": {
    "prefix": "r3yohei_TwoPointer",
    "body": [
      "/// while1重尺取法",
      "/// https://zenn.dev/luke256/articles/0d60a95fd86ffa",
      "struct TwoPointer {",
      "    n: usize,",
      "    t: Vec<i64>,",
      "}",
      "impl TwoPointer {",
      "    fn new(n: usize, t: Vec<i64>) -> Self {",
      "        Self { n, t }",
      "    }",
      "    fn run(&mut self) {",
      "        let mut l = 0;",
      "        let mut r = 0;",
      "        while l < self.n {",
      "            if r == self.n || todo!(\"条件を満たさない場合を記載\") {",
      "                l += 1;",
      "            } else {",
      "                r += 1;",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "r3yohei_Xoshiro256": {
    "prefix": "r3yohei_Xoshiro256",
    "body": [
      "/// seed値を4つの初期状態値に分割するためのsplit mix 64",
      "struct SplitMix64 {",
      "    s: u64,",
      "}",
      "impl SplitMix64 {",
      "    fn new(seed: u64) -> Self {",
      "        Self { s: seed }",
      "    }",
      "    fn next_u64(&mut self) -> u64 {",
      "        self.s = self.s.wrapping_add(0x9e3779b97f4a7c15);",
      "        let mut z = self.s;",
      "        z = (z ^ z >> 30).wrapping_mul(0xbf58476d1ce4e5b9);",
      "        z = (z ^ z >> 27).wrapping_mul(0x94d049bb133111eb);",
      "        z ^ z >> 31",
      "    }",
      "}",
      "/// Xoshiro256による乱数生成器",
      "struct Xoshiro256 {",
      "    s: [u64; 4],",
      "}",
      "impl Xoshiro256 {",
      "    fn new(seed: u64) -> Self {",
      "        let mut split_mix_64 = SplitMix64::new(seed);",
      "        let mut s = [0; 4];",
      "        for si in &mut s {",
      "            *si = split_mix_64.next_u64();",
      "        }",
      "        Self { s }",
      "    }",
      "    fn next_u64(&mut self) -> u64 {",
      "        let result = (self.s[1].wrapping_mul(5)).rotate_left(7).wrapping_mul(9);",
      "        let t = self.s[1] << 17;",
      "        self.s[2] ^= self.s[0];",
      "        self.s[3] ^= self.s[1];",
      "        self.s[1] ^= self.s[2];",
      "        self.s[0] ^= self.s[3];",
      "        self.s[2] ^= t;",
      "        self.s[3] = self.s[3].rotate_left(45);",
      "        result",
      "    }",
      "    fn gen_usize(&mut self, lower: usize, upper: usize) -> usize {",
      "        assert!(lower < upper);",
      "        let count = upper - lower;",
      "        (self.next_u64() % count as u64) as usize + lower",
      "    }",
      "    fn gen_i64(&mut self, lower: i64, upper: i64) -> i64 {",
      "        assert!(lower < upper);",
      "        let count = upper - lower;",
      "        (self.next_u64() % count as u64) as i64 + lower",
      "    }",
      "    fn gen_f64(&mut self) -> f64 {",
      "        const UPPER_MASK: u64 = 0x3ff0000000000000;",
      "        const LOWER_MASK: u64 = 0xfffffffffffff;",
      "        let result = UPPER_MASK | (self.next_u64() & LOWER_MASK);",
      "        let result: f64 = unsafe { std::mem::transmute(result) };",
      "        result - 1.0",
      "    }",
      "    fn gen_bool(&mut self, prob: f64) -> bool {",
      "        self.gen_f64() < prob",
      "    }",
      "    fn fisher_yates_shuffle<T>(&mut self, items: &mut [T]) {",
      "        for i in (1..items.len()).rev() {",
      "            let j = (self.next_u64() as usize) % (i + 1);",
      "            items.swap(j, i);",
      "        }",
      "    }",
      "}"
    ]
  },
  "r3yohei_argsort": {
    "prefix": "r3yohei_argsort",
    "body": [
      "/// ベクタのargsort",
      "fn argsort<T: Ord>(v: &[T]) -> Vec<usize> {",
      "    let mut idx = (0..v.len()).collect::<Vec<_>>();",
      "    idx.sort_by(|&i, &j| v[i].cmp(&v[j]));",
      "    idx",
      "}"
    ]
  },
  "r3yohei_bfs": {
    "prefix": "r3yohei_bfs",
    "body": [
      "/// 隣接リスト表現に対するBFS",
      "fn bfs(edges: &Vec<Vec<usize>>, s: usize) {",
      "    let mut deque = VecDeque::new();",
      "    deque.push_back(s);",
      "    let mut dist = vec![-1; edges.len()];",
      "    dist[s] = 0;",
      "    while let Some(crt) = deque.pop_front() {",
      "        for &to in &edges[crt] {",
      "            if dist[to] == -1 {",
      "                dist[to] = dist[crt] + 1;",
      "                deque.push_back(to);",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "r3yohei_bfs_grid": {
    "prefix": "r3yohei_bfs_grid",
    "body": [
      "/// 二次元グリッド上のBFS",
      "fn bfs(c: &Vec<Vec<char>>, s_x: usize, s_y: usize) {",
      "    let h = c.len();",
      "    let w = c[0].len();",
      "    const DIJ: [(usize, usize); 4] = [(1, 0), (0, 1), (!0, 0), (0, !0)];",
      "    let mut deque = VecDeque::new();",
      "    let mut visited = vec![vec![false; w]; h];",
      "    deque.push_back((s_x, s_y));",
      "    visited[s_x][s_y] = true;",
      "    while let Some((crt_x, crt_y)) = deque.pop_front() {",
      "        for i in 0..4 {",
      "            let to_x = crt_x.wrapping_add(DIJ[i].0);",
      "            let to_y = crt_y.wrapping_add(DIJ[i].1);",
      "            if to_x < h && to_y < w {",
      "                if c[to_x][to_y] == '.' && !visited[to_x][to_y] {",
      "                    deque.push_back((to_x, to_y));",
      "                    visited[to_x][to_y] = true;",
      "                }",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "r3yohei_bfs_grid_until_wall": {
    "prefix": "r3yohei_bfs_grid_until_wall",
    "body": [
      "/// 二次元グリッド上で，壁にぶつかるまで動くBFS",
      "fn bfs_until_wall(c: &Vec<Vec<char>>, s_x: usize, s_y: usize) -> Vec<Vec<bool>> {",
      "    let h = c.len();",
      "    let w = c[0].len();",
      "    const DIJ: [(usize, usize); 4] = [(1, 0), (0, 1), (!0, 0), (0, !0)];",
      "    let mut deque = VecDeque::new();",
      "    let mut visited = vec![vec![false; w]; h];",
      "    deque.push_back((s_x, s_y));",
      "    visited[s_x][s_y] = true;",
      "    let mut stopped = vec![vec![false; w]; h];",
      "    while let Some((frm_x, frm_y)) = deque.pop_front() {",
      "        for &(dx, dy) in &DIJ {",
      "            let mut to_x = frm_x;",
      "            let mut to_y = frm_y;",
      "            while c[to_x.wrapping_add(dx)][to_y.wrapping_add(dy)] == '.' {",
      "                to_x = to_x.wrapping_add(dx);",
      "                to_y = to_y.wrapping_add(dy);",
      "                visited[to_x][to_y] = true;",
      "            }",
      "            if !stopped[to_x][to_y] {",
      "                stopped[to_x][to_y] = true;",
      "                deque.push_back((to_x, to_y));",
      "            }",
      "        }",
      "    }",
      "    visited",
      "}"
    ]
  },
  "r3yohei_change_radix": {
    "prefix": "r3yohei_change_radix",
    "body": [
      "/// 文字列の数字sをa進数からb進数の文字列に変換する",
      "/// 大きな桁の数字を扱うために文字列としている",
      "pub fn change_radix(s: &str, a: i64, b: i64) -> String {",
      "    let mut base10: i64 = 0;",
      "    for (i, c) in s.chars().rev().enumerate() {",
      "        base10 += c.to_digit(10).unwrap() as i64 * a.pow(i as u32);",
      "    }",
      "    if base10 == 0 {",
      "        return \"0\".to_string();",
      "    }",
      "    let mut result = String::new();",
      "    while base10 != 0 {",
      "        result.push(std::char::from_digit((base10 % b) as u32, 10).unwrap());",
      "        base10 /= b;",
      "    }",
      "    return result.chars().rev().collect::<String>();",
      "}"
    ]
  },
  "r3yohei_dfs": {
    "prefix": "r3yohei_dfs",
    "body": [
      "/// 隣接リスト表現に対するDFS",
      "fn dfs(crt: usize, pre: usize, edges: &Vec<Vec<usize>>, mut visited: &mut Vec<bool>) {",
      "    visited[crt] = true;",
      "    todo!(\"行きがけの処理\");",
      "    for &to in &edges[crt] {",
      "        if visited[to] {",
      "            continue;",
      "        }",
      "        dfs(to, crt, edges, visited);",
      "    }",
      "    todo!(\"帰りがけの処理\");",
      "}"
    ]
  },
  "r3yohei_dfs_grid": {
    "prefix": "r3yohei_dfs_grid",
    "body": [
      "/// 二次元グリッド上のDFS",
      "fn dfs(",
      "    c: &Vec<Vec<char>>,",
      "    crt_x: usize,",
      "    crt_y: usize,",
      "    prev_x: usize,",
      "    prev_y: usize,",
      "    mut visited: &mut Vec<Vec<bool>>,",
      ") {",
      "    const DIJ: [(usize, usize); 4] = [(1, 0), (0, 1), (!0, 0), (0, !0)];",
      "    visited[crt_x][crt_y] = true;",
      "    todo!(\"行きがけの処理\");",
      "    for i in 0..4 {",
      "        let to_x = crt_x.wrapping_add(DIJ[i].0);",
      "        let to_y = crt_y.wrapping_add(DIJ[i].1);",
      "        if to_x < c.len() && to_y < c[0].len() {",
      "            if (to_x == prev_x && to_y == prev_y) || c[to_x][to_y] == '#' || visited[to_x][to_y] {",
      "                continue;",
      "            }",
      "            dfs(c, to_x, to_y, crt_x, crt_y, &mut visited);",
      "        }",
      "    }",
      "    todo!(\"帰りがけの処理\");",
      "}"
    ]
  },
  "r3yohei_dijkstra": {
    "prefix": "r3yohei_dijkstra",
    "body": [
      "/// 隣接リスト表現に対するダイクストラ法",
      "fn dijkstra(edges: &Vec<Vec<(usize, i64)>>, s: usize) -> Vec<i64> {",
      "    let inf = 1_000_000_000;",
      "    let mut dist = vec![inf; edges.len()];",
      "    dist[s] = 0;",
      "    let mut bh = BinaryHeap::new();",
      "    bh.push((Reverse(0), s));",
      "    while let Some((Reverse(dist_crt), crt)) = bh.pop() {",
      "        if dist[crt] < dist_crt {",
      "            continue;",
      "        }",
      "        for &(to, w) in &edges[crt] {",
      "            if dist_crt + w < dist[to] {",
      "                dist[to] = dist[crt] + w;",
      "                bh.push((Reverse(dist[to]), to));",
      "            }",
      "        }",
      "    }",
      "    dist",
      "}"
    ]
  },
  "r3yohei_gaussian_process_regression": {
    "prefix": "r3yohei_gaussian_process_regression",
    "body": [
      "/// ガウス過程回帰のカーネルのハイパーパラメータ",
      "#[derive(Debug, Clone, Copy)]",
      "struct GaussianProcessRegressionParameter {",
      "    theta1: f64,",
      "    theta2: f64,",
      "    theta3: f64,",
      "}",
      "impl GaussianProcessRegressionParameter {",
      "    fn new(theta1: f64, theta2: f64, theta3: f64) -> Self {",
      "        Self {",
      "            theta1,",
      "            theta2,",
      "            theta3,",
      "        }",
      "    }",
      "}",
      "/// 1次元ガウス過程回帰モデル",
      "#[derive(Debug, Clone)]",
      "struct GaussianProcessRegression {",
      "    x: Vec<DVector<f64>>,",
      "    y: Vec<f64>,",
      "    param: GaussianProcessRegressionParameter,",
      "}",
      "impl GaussianProcessRegression {",
      "    pub fn new() -> Self {",
      "        Self {",
      "            x: vec![],",
      "            y: vec![],",
      "            param: GaussianProcessRegressionParameter::new(1.0, 1.0, 0.1),",
      "        }",
      "    }",
      "    pub fn collect_data(&mut self, xi: DVector<f64>, yi: f64) {",
      "        self.x.push(xi);",
      "        self.y.push(yi);",
      "    }",
      "    pub fn predict(&self, x_test: &DMatrix<f64>) -> (Vec<f64>, Vec<f64>) {",
      "        let mut x_train = DMatrix::from_row_slice(",
      "            self.x.len(),",
      "            self.x[0].len(),",
      "            &self.x.iter().flatten().copied().collect_vec(),",
      "        );",
      "        let mut y_train = DVector::from_vec(self.y.clone());",
      "        let y_average = y_train.mean();",
      "        y_train.add_scalar_mut(-y_average);",
      "        let train_len = self.x.len();",
      "        let test_len = x_test.shape().0;",
      "        let kernel_mat = self.compute_kernel_matrix(&x_train);",
      "        let kernel_lu = kernel_mat.lu();",
      "        let yy = kernel_lu.solve(&y_train).unwrap();",
      "        let mut mean = vec![];",
      "        let mut covariance = vec![];",
      "        for j in 0..test_len {",
      "            let mut k = vec![];",
      "            for i in 0..train_len {",
      "                let xi = x_train.row(i).transpose();",
      "                let xj = x_test.row(j).transpose();",
      "                let kernel = self.kernel(&xi, &xj, i, j);",
      "                k.push(kernel);",
      "            }",
      "            let k = DVector::from_vec(k);",
      "            let xj = x_test.row(j).transpose();",
      "            let s = self.kernel(&xj, &xj, j + train_len, j + train_len);",
      "            mean.push(k.dot(&yy) + y_average);",
      "            covariance.push(s - (k.transpose() * kernel_lu.solve(&k).unwrap())[(0, 0)]);",
      "        }",
      "        (mean, covariance)",
      "    }",
      "    fn kernel(&self, xi: &DVector<f64>, xj: &DVector<f64>, i: usize, j: usize) -> f64 {",
      "        let diff = xi - xj;",
      "        let norm = diff.component_mul(&diff).sum();",
      "        let mut kernel = self.param.theta1 * (-norm / self.param.theta2.powf(2.0)).exp();",
      "        if i == j {",
      "            kernel += self.param.theta3;",
      "        }",
      "        kernel",
      "    }",
      "    fn compute_kernel_matrix(&self, x_train: &DMatrix<f64>) -> DMatrix<f64> {",
      "        let train_len = x_train.shape().0;",
      "        let mut kernel_mat = DMatrix::zeros(train_len, train_len);",
      "        for i in 0..train_len {",
      "            for j in 0..train_len {",
      "                let xi = x_train.row(i).transpose();",
      "                let xj = x_train.row(j).transpose();",
      "                kernel_mat[(i, j)] = self.kernel(&xi, &xj, i, j);",
      "            }",
      "        }",
      "        kernel_mat",
      "    }",
      "    fn log_likelihood(&self, y_train: &DVector<f64>, kernel_mat: DMatrix<f64>) -> f64 {",
      "        let det = kernel_mat.determinant().max(1e-100);",
      "        -det.ln() - (y_train.transpose() * kernel_mat.lu().solve(y_train).unwrap())[(0, 0)]",
      "    }",
      "    fn search_ranges(&self) -> (Vec<f64>, Vec<f64>, Vec<f64>) {",
      "        let theta1_range = (3..10).map(|v| 2.0_f64.powi(v)).collect_vec();",
      "        let theta2_range = (2..12).map(|v| 5.0 * v as f64).collect_vec();",
      "        let theta3_range = (0..6).map(|v| 2.0_f64.powi(v)).collect_vec();",
      "        (theta1_range, theta2_range, theta3_range)",
      "    }",
      "    pub fn grid_search(&mut self) {",
      "        let x_train = DMatrix::from_row_slice(",
      "            self.x.len(),",
      "            self.x[0].len(),",
      "            &self.x.iter().flatten().copied().collect_vec(),",
      "        );",
      "        let mut y_train = DVector::from_vec(self.y.clone());",
      "        let y_average = y_train.mean();",
      "        y_train.add_scalar_mut(-y_average);",
      "        let mut best_param = self.param;",
      "        let kernel_mat = self.compute_kernel_matrix(&x_train);",
      "        let mut best_likelihood = self.log_likelihood(&y_train, kernel_mat);",
      "        let (theta1_range, theta2_range, theta3_range) = self.search_ranges();",
      "        for &theta1 in &theta1_range {",
      "            for &theta2 in &theta2_range {",
      "                for &theta3 in &theta3_range {",
      "                    self.param = GaussianProcessRegressionParameter::new(theta1, theta2, theta3);",
      "                    let kernel_mat = self.compute_kernel_matrix(&x_train);",
      "                    let likelihood = self.log_likelihood(&y_train, kernel_mat);",
      "                    if best_likelihood < likelihood {",
      "                        best_likelihood = likelihood;",
      "                        best_param =",
      "                            GaussianProcessRegressionParameter::new(theta1, theta2, theta3);",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        self.param = best_param;",
      "    }",
      "}"
    ]
  },
  "r3yohei_get_time": {
    "prefix": "r3yohei_get_time",
    "body": [
      "/// 現在時刻を返す",
      "pub fn get_time() -> f64 {",
      "    static mut STIME: f64 = -1.0;",
      "    let t = std::time::SystemTime::now()",
      "        .duration_since(std::time::UNIX_EPOCH)",
      "        .unwrap();",
      "    let ms = t.as_secs() as f64 + t.subsec_nanos() as f64 * 1e-9;",
      "    unsafe {",
      "        if STIME < 0.0 {",
      "            STIME = ms;",
      "        }",
      "        #[cfg(feature = \"local\")]",
      "        {",
      "            (ms - STIME) * 1.5",
      "        }",
      "        #[cfg(not(feature = \"local\"))]",
      "        {",
      "            ms - STIME",
      "        }",
      "    }",
      "}"
    ]
  },
  "r3yohei_is_ok": {
    "prefix": "r3yohei_is_ok",
    "body": [
      "fn is_ok(mid: i64) -> bool {",
      "    todo!();",
      "}"
    ]
  },
  "r3yohei_is_prime": {
    "prefix": "r3yohei_is_prime",
    "body": [
      "/// 素数判定",
      "/// O(√n)",
      "/// 1~√nまででnを割り切るものがあれば素数でない",
      "fn is_prime(n: usize) -> bool {",
      "    if n <= 1 {",
      "        return false;",
      "    }",
      "    let rootn = (n as f64).sqrt().floor() as usize;",
      "    for i in 2..=rootn {",
      "        if n % i == 0 {",
      "            return false;",
      "        }",
      "    }",
      "    true",
      "}"
    ]
  },
  "r3yohei_largest_square_in_grid": {
    "prefix": "r3yohei_largest_square_in_grid",
    "body": [
      "/// グリッド内の最大正方形の面積を求める O(HW)",
      "/// https://qiita.com/H20/items/884551b4965739176afc",
      "fn largest_square_in_grid(grid: &Vec<Vec<bool>>) -> Vec<Vec<i64>> {",
      "    let H = grid.len();",
      "    let W = grid[0].len();",
      "    let mut dp = vec![vec![-1; W]; H];",
      "    for i in 0..H {",
      "        for j in 0..W {",
      "            if grid[i][j] {",
      "                if i == 0 || j == 0 {",
      "                    dp[i][j] = 1;",
      "                } else {",
      "                    dp[i][j] = dp[i - 1][j].min(dp[i][j - 1]).min(dp[i - 1][j - 1]) + 1;",
      "                }",
      "            } else {",
      "                dp[i][j] = 0;",
      "            }",
      "        }",
      "    }",
      "    dp",
      "}"
    ]
  },
  "r3yohei_lis": {
    "prefix": "r3yohei_lis",
    "body": [
      "/// 最長部分増加列(LIS)を求める O(NlogN)",
      "/// https://qiita.com/python_walker/items/d1e2be789f6e7a0851e5",
      "fn lis(a: &[i64]) -> usize {",
      "    let inf: i64 = 1_000_000_000;",
      "    let mut dp = vec![inf; a.len()];",
      "    let mut p = vec![0; a.len()];",
      "    for (i, &ai) in a.iter().enumerate() {",
      "        let j = dp.lower_bound(&ai);",
      "        dp[j] = ai;",
      "        p[i] = j + 1;",
      "    }",
      "    let mut ans = 0;",
      "    for i in 0..a.len() {",
      "        if dp[i] != inf {",
      "            ans += 1;",
      "        }",
      "    }",
      "    ans",
      "}"
    ]
  },
  "r3yohei_lucas_theorem": {
    "prefix": "r3yohei_lucas_theorem",
    "body": [
      "/// p-1C0 ~ p-1Cp-1 をDPで求める",
      "/// comb[i][j] := iCj mod p (i >= j)",
      "/// iCj = i-1Cj-1 + i-1Cjであることを利用",
      "fn ncr_mod(p: usize) -> Vec<Vec<usize>> {",
      "    let mut comb = vec![vec![0; p]; p];",
      "    comb[0][0] = 1;",
      "    for i in 1..p {",
      "        comb[i][0] = 1;",
      "        for j in (1..=i).rev() {",
      "            comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % p;",
      "        }",
      "    }",
      "    comb",
      "}",
      "/// リュカの定理によりnCr mod pを求める",
      "/// O(p^2 + log_p(n))",
      "fn ncr_lucas(mut n: usize, mut r: usize, p: usize) -> usize {",
      "    let mut ret = 1;",
      "    let comb = ncr_mod(p);",
      "    while n > 0 {",
      "        let n_next = n % p;",
      "        let r_next = r % p;",
      "        ret *= comb[n_next][r_next];",
      "        ret %= p;",
      "        n /= p;",
      "        r /= p;",
      "    }",
      "    ret",
      "}"
    ]
  },
  "r3yohei_meguru_bisect": {
    "prefix": "r3yohei_meguru_bisect",
    "body": [
      "fn is_ok(mid: i64) -> bool {",
      "    todo!();",
      "}",
      "/// めぐる式二分探索(https://aotamasaki.hatenablog.com/entry/meguru_bisect)",
      "/// ng: '取り得る最小の値' - 1",
      "/// ok: '取り得る最大の値' + 1",
      "fn meguru_bisect(mut ng: i64, mut ok: i64) -> i64 {",
      "    while (ok - ng).abs() > 1 {",
      "        let mid = (ok + ng) / 2;",
      "        if is_ok(mid) {",
      "            ok = mid;",
      "        } else {",
      "            ng = mid;",
      "        }",
      "    }",
      "    ok",
      "}"
    ]
  },
  "r3yohei_memorization_recursion": {
    "prefix": "r3yohei_memorization_recursion",
    "body": [
      "/// メモ化再帰関数",
      "/// 例: 区間DP",
      "pub fn memo_rec(l: usize, r: usize, a: &[i64], mut dp: &mut [Vec<Option<i64>>]) -> i64 {",
      "    if l == r {",
      "        return 0;",
      "    }",
      "    return match dp[l][r] {",
      "        Some(val) => val,",
      "        None => {",
      "            let val = memo_rec(l + 1, r, &a, &mut dp).max(memo_rec(l, r - 1, &a, &mut dp));",
      "            dp[l][r] = Some(val);",
      "            val",
      "        }",
      "    };",
      "}"
    ]
  },
  "r3yohei_min_cost_flow": {
    "prefix": "r3yohei_min_cost_flow",
    "body": [
      "#[derive(Debug, Clone, Copy)]",
      "struct Edge {",
      "    to: usize,",
      "    cap: isize,",
      "    cost: i64,",
      "    rev: usize,",
      "}",
      "#[derive(Debug, Clone)]",
      "struct MinCostFlow {",
      "    n: usize,",
      "    graph: Vec<Vec<Edge>>,",
      "    h: Vec<i64>,",
      "    dist: Vec<i64>,",
      "    prev: Vec<(usize, usize)>,",
      "}",
      "impl MinCostFlow {",
      "    fn new(n: usize) -> Self {",
      "        MinCostFlow {",
      "            n: n,",
      "            graph: vec![vec![]; n],",
      "            h: vec![0; n],",
      "            dist: vec![0; n],",
      "            prev: vec![(0, 0); n],",
      "        }",
      "    }",
      "    fn add_edge(&mut self, from: usize, to: usize, cap: isize, cost: i64) {",
      "        let fst = Edge {",
      "            to: to,",
      "            cap: cap,",
      "            cost: cost,",
      "            rev: self.graph[to].len(),",
      "        };",
      "        self.graph[from].push(fst);",
      "        let snd = Edge {",
      "            to: from,",
      "            cap: 0,",
      "            cost: -cost,",
      "            rev: self.graph[from].len() - 1,",
      "        };",
      "        self.graph[to].push(snd);",
      "    }",
      "    fn min_cost_flow(&mut self, s: usize, t: usize, mut f: isize) -> i64 {",
      "        let n = self.n;",
      "        let inf: i64 = std::i64::MAX / 10;",
      "        let mut res = 0;",
      "        let h = &mut self.h;",
      "        let dist = &mut self.dist;",
      "        while f > 0 {",
      "            let mut que = std::collections::BinaryHeap::<(i64, usize)>::new();",
      "            for i in 0..n {",
      "                dist[i] = inf;",
      "            }",
      "            dist[s] = 0;",
      "            que.push((0, s));",
      "            while let Some((d, v)) = que.pop() {",
      "                let d = -d;",
      "                if dist[v] < d {",
      "                    continue;",
      "                }",
      "                for (i, &e) in self.graph[v].iter().enumerate() {",
      "                    if e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to] {",
      "                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];",
      "                        self.prev[e.to] = (v, i);",
      "                        que.push((-dist[e.to], e.to));",
      "                    }",
      "                }",
      "            }",
      "            if dist[t] == inf {",
      "                return -1;",
      "            }",
      "            for i in 0..n {",
      "                h[i] += dist[i];",
      "            }",
      "            let mut d = f;",
      "            let mut i = t;",
      "            while i != s {",
      "                let (pv, pe) = self.prev[i];",
      "                d = std::cmp::min(d, self.graph[pv][pe].cap);",
      "                i = pv;",
      "            }",
      "            f -= d;",
      "            res += d as i64 * h[t];",
      "            i = t;",
      "            while i != s {",
      "                let (pv, pe) = self.prev[i];",
      "                self.graph[pv][pe].cap -= d;",
      "                let erev = self.graph[pv][pe].rev;",
      "                self.graph[i][erev].cap += d;",
      "                i = pv;",
      "            }",
      "        }",
      "        return res;",
      "    }",
      "}"
    ]
  },
  "r3yohei_modinv": {
    "prefix": "r3yohei_modinv",
    "body": [
      "/// x^p mod MODを繰り返し二乗法により求める",
      "/// O(log(p))",
      "fn modpow(mut x: i64, mut p: i64, mod_num: i64) -> i64 {",
      "    let mut ret = 1;",
      "    while p > 0 {",
      "        if p & 1 == 1 {",
      "            ret *= x;",
      "            ret %= mod_num;",
      "        }",
      "        x *= x;",
      "        x %= mod_num;",
      "        p >>= 1;",
      "    }",
      "    ret",
      "}",
      "/// MODを法とするxの逆元を見つける",
      "fn modinv(x: i64, mod_num: i64) -> i64 {",
      "    modpow(x, mod_num - 2, mod_num)",
      "}"
    ]
  },
  "r3yohei_modpow": {
    "prefix": "r3yohei_modpow",
    "body": [
      "/// x^p mod MODを繰り返し二乗法により求める",
      "/// O(log(p))",
      "fn modpow(mut x: i64, mut p: i64, mod_num: i64) -> i64 {",
      "    let mut ret = 1;",
      "    while p > 0 {",
      "        if p & 1 == 1 {",
      "            ret *= x;",
      "            ret %= mod_num;",
      "        }",
      "        x *= x;",
      "        x %= mod_num;",
      "        p >>= 1;",
      "    }",
      "    ret",
      "}"
    ]
  },
  "r3yohei_ncr_mod": {
    "prefix": "r3yohei_ncr_mod",
    "body": [
      "/// p-1C0 ~ p-1Cp-1 をDPで求める",
      "/// comb[i][j] := iCj mod p (i >= j)",
      "/// iCj = i-1Cj-1 + i-1Cjであることを利用",
      "fn ncr_mod(p: usize) -> Vec<Vec<usize>> {",
      "    let mut comb = vec![vec![0; p]; p];",
      "    comb[0][0] = 1;",
      "    for i in 1..p {",
      "        comb[i][0] = 1;",
      "        for j in (1..=i).rev() {",
      "            comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % p;",
      "        }",
      "    }",
      "    comb",
      "}"
    ]
  },
  "r3yohei_ncr_small": {
    "prefix": "r3yohei_ncr_small",
    "body": [
      "/// n <= 200くらいまでの組合せ",
      "fn nCr_small(n: u128, r: u128) -> u128 {",
      "    //! オーバーフローしないように，以下の工夫をする",
      "    //! nCr = n*(n-1)*...*(n-r+1) / 1*2*...*r より，",
      "    //! n/1 * (n-1)/2 *...* (n-r+1) / r",
      "    let mut ncr = 1;",
      "    for i in 1..=r {",
      "        ncr *= n - i + 1;",
      "        ncr /= i;",
      "    }",
      "    ncr",
      "}"
    ]
  },
  "r3yohei_next_permutation": {
    "prefix": "r3yohei_next_permutation",
    "body": [
      "/// イテレータの並びのうち，辞書順で次の並びのものがあるかどうかを判定する",
      "/// あれば，イテレータも並び替えられる",
      "pub fn next_permutation<T>(a: &mut [T]) -> bool",
      "where",
      "    T: PartialOrd,",
      "{",
      "    let n = a.len();",
      "    for i in (1..n).rev() {",
      "        if a[i - 1] < a[i] {",
      "            let mut j = n - 1;",
      "            while a[i - 1] >= a[j] {",
      "                j -= 1;",
      "            }",
      "            a.swap(i - 1, j);",
      "            a[i..n].reverse();",
      "            return true;",
      "        }",
      "    }",
      "    a.reverse();",
      "    false",
      "}"
    ]
  },
  "r3yohei_prim": {
    "prefix": "r3yohei_prim",
    "body": [
      "/// プリム法により最小全域木のコストを返す",
      "/// O(N + MlogN)",
      "pub fn prim(edges: &Vec<Vec<(usize, i64)>>) -> i64 {",
      "    let mut cost = 0;",
      "    let mut visited = vec![false; edges.len()];",
      "    let mut bh = BinaryHeap::new();",
      "    bh.push((Reverse(0), 0, !0));",
      "    while let Some((Reverse(w1), crt, frm)) = bh.pop() {",
      "        if visited[crt] {",
      "            continue;",
      "        }",
      "        visited[crt] = true;",
      "        if frm != !0 {",
      "            cost += w1;",
      "        }",
      "        for &(to, w2) in &edges[crt] {",
      "            if visited[to] {",
      "                continue;",
      "            }",
      "            bh.push((Reverse(w2), to, crt));",
      "        }",
      "    }",
      "    cost",
      "}"
    ]
  },
  "r3yohei_prime_factorization": {
    "prefix": "r3yohei_prime_factorization",
    "body": [
      "/// 素数判定",
      "/// O(√n)",
      "/// 1~√nまででnを割り切るものがあれば素数でない",
      "fn is_prime(n: usize) -> bool {",
      "    if n <= 1 {",
      "        return false;",
      "    }",
      "    let rootn = (n as f64).sqrt().floor() as usize;",
      "    for i in 2..=rootn {",
      "        if n % i == 0 {",
      "            return false;",
      "        }",
      "    }",
      "    true",
      "}",
      "/// 素因数分解",
      "/// is_prime()に依存",
      "fn prime_factorization(mut n: usize) -> Vec<usize> {",
      "    let mut factor = vec![];",
      "    if is_prime(n) {",
      "        factor.push(n);",
      "        factor",
      "    } else {",
      "        let rootn = (n as f64).sqrt().floor() as usize;",
      "        for i in 2..=rootn {",
      "            while n % i == 0 {",
      "                n /= i;",
      "                factor.push(i);",
      "            }",
      "        }",
      "        if n != 1 {",
      "            factor.push(n);",
      "        }",
      "        factor",
      "    }",
      "}"
    ]
  },
  "r3yohei_run_length_encoding": {
    "prefix": "r3yohei_run_length_encoding",
    "body": [
      "/// ランレングス符号化",
      "/// s = \"RRRLLRLRRLLLLRLRR\"などを",
      "/// [(R, 3), (L, 2), (R, 1), (L, 1), (R, 2), (L, 4), (R, 1), (L, 1), (R, 2)]",
      "/// のように変換する",
      "/// O(n)",
      "fn run_length_encoding(s: Vec<i64>) -> Vec<(i64, usize)> {",
      "    let mut tmp = s[0];",
      "    let mut cnt = 0;",
      "    let mut encode = vec![];",
      "    for &si in &s {",
      "        if tmp == si {",
      "            cnt += 1;",
      "        } else {",
      "            encode.push((tmp, cnt));",
      "            tmp = si;",
      "            cnt = 1;",
      "        }",
      "    }",
      "    encode.push((tmp, cnt));",
      "    encode",
      "}"
    ]
  },
  "r3yohei_sieve_of_eratosthenes": {
    "prefix": "r3yohei_sieve_of_eratosthenes",
    "body": [
      "/// エラトステネスの篩",
      "/// n以下の素数を列挙する",
      "/// O(nloglogn)",
      "fn sieve_of_eratosthenes(n: usize) -> Vec<usize> {",
      "    if n <= 1 {",
      "        return vec![];",
      "    }",
      "    let mut sieve = vec![true; n + 1];",
      "    sieve[0] = false;",
      "    sieve[1] = false;",
      "    let mut prime = vec![];",
      "    for i in 2..(n + 1) {",
      "        if sieve[i] {",
      "            prime.push(i);",
      "            for j in (i * 2..n + 1).step_by(i) {",
      "                sieve[j] = false;",
      "            }",
      "        }",
      "    }",
      "    prime",
      "}"
    ]
  },
  "r3yohei_sieve_of_eratosthenes_from_l_to_r": {
    "prefix": "r3yohei_sieve_of_eratosthenes_from_l_to_r",
    "body": [
      "/// L以上R以下の素数のエラトステネスの篩による列挙",
      "/// is_prime[x]: x+Lが素数かどうか",
      "fn sieve_of_eratosthenes_from_l_to_r(n: usize, l: usize, r: usize) -> Vec<usize> {",
      "    if n <= 1 {",
      "        return vec![];",
      "    }",
      "    let mut is_prime = vec![true; r - l + 1];",
      "    if l == 1 {",
      "        is_prime[0] = false;",
      "    }",
      "    let rootn = (n as f64).sqrt().floor() as usize;",
      "    for i in 2..=rootn {",
      "        let min_value = ((l + i - 1) / i) * i;",
      "        for j in (min_value..=r).step_by(i) {",
      "            if j == i {",
      "                continue;",
      "            }",
      "            is_prime[j - l] = false;",
      "        }",
      "    }",
      "    let mut prime = vec![];",
      "    for i in 0..r - l + 1 {",
      "        if is_prime[i] {",
      "            prime.push(i + l);",
      "        }",
      "    }",
      "    prime",
      "}"
    ]
  },
  "r3yohei_sinkhorn_knopp": {
    "prefix": "r3yohei_sinkhorn_knopp",
    "body": [
      "/// Sinkhorn-Knoppアルゴリズム",
      "/// [つるさんのブログ](https://theory-and-me.hatenablog.com/entry/2021/05/09/181435)",
      "fn sinkhorn_knopp(",
      "    a: Vec<f64>,",
      "    b: Vec<f64>,",
      "    C: Vec<Vec<f64>>,",
      "    lambda: f64,",
      "    tolerance: f64,",
      ") -> Vec<Vec<f64>> {",
      "    //! N件のソースからM件のターゲットにいくらかモノを運ぶ",
      "    //! 各ソースsiにはai個の供給があり，各ターゲットtiにはbi個の需要がある",
      "    //! Σ(1~n)ai = Σ(1~M)biとする",
      "    //! si->tj にモノを運ぶのに，cijの輸送コストがかかる",
      "    //! si->tjへの輸送量xijを適切に決めて，各ターゲットの要求を満たしつつ輸送コストの和を最小化する",
      "    //! Args:",
      "    //!     a: ソースの供給量ベクタ",
      "    //!     b: ターゲットの需要量ベクタ",
      "    //!     C: ソースiからターゲットjへの輸送コストcijの行列",
      "    //!     lambda: Sinkhorn-Knoppアルゴリズムの性能をコントロールするハイパーパラメータ (>0)",
      "    //!             大きいほど真の値に近づくが，収束が遅くなる",
      "    //!             ただし，あまりに大きい値にするとexp(-λ*cij)が破綻する",
      "    //!     tolerance: ベクタu, vのノルムがこれより変化しなくなったら収束したとみなす",
      "    //! Returns:",
      "    //!     R: ソースiからターゲットjへの輸送量rijの行列",
      "    let K = DMatrix::from_row_slice(",
      "        C.len(),",
      "        C[0].len(),",
      "        &C.iter()",
      "            .flatten()",
      "            .map(|&cij| f64::exp(-lambda * cij))",
      "            .collect_vec(),",
      "    );",
      "    let K_t = K.transpose();",
      "    let a = DVector::from_vec(a);",
      "    let b = DVector::from_vec(b);",
      "    let mut u = DVector::from_element(C.len(), 1.0);",
      "    let mut v = b.component_div(&(&K_t * &u));",
      "    let mut iter = 0;",
      "    loop {",
      "        iter += 1;",
      "        let next_u = a.component_div(&(&K * &v));",
      "        let next_v = b.component_div(&(&K_t * &u));",
      "        let error = (&next_u - &u).norm() + (&next_v - &v).norm();",
      "        if error < tolerance {",
      "            eprintln!(\"sinkhorn-knopp is converged after {} iterations\", iter);",
      "            break;",
      "        }",
      "        u = next_u;",
      "        v = next_v;",
      "    }",
      "    let U = DMatrix::from_diagonal(&u);",
      "    let V = DMatrix::from_diagonal(&v);",
      "    let R = U * K * V;",
      "    let R: Vec<Vec<f64>> = R.row_iter().map(|r| r.iter().copied().collect()).collect();",
      "    R",
      "}"
    ]
  },
  "r3yohei_split_mix_64": {
    "prefix": "r3yohei_split_mix_64",
    "body": [
      "/// seed値を4つの初期状態値に分割するためのsplit mix 64",
      "struct SplitMix64 {",
      "    s: u64,",
      "}",
      "impl SplitMix64 {",
      "    fn new(seed: u64) -> Self {",
      "        Self { s: seed }",
      "    }",
      "    fn next_u64(&mut self) -> u64 {",
      "        self.s = self.s.wrapping_add(0x9e3779b97f4a7c15);",
      "        let mut z = self.s;",
      "        z = (z ^ z >> 30).wrapping_mul(0xbf58476d1ce4e5b9);",
      "        z = (z ^ z >> 27).wrapping_mul(0x94d049bb133111eb);",
      "        z ^ z >> 31",
      "    }",
      "}"
    ]
  },
  "r3yohei_transpose": {
    "prefix": "r3yohei_transpose",
    "body": [
      "/// 二次元配列の転置を求める",
      "fn transpose(a: &Vec<Vec<i64>>) -> Vec<Vec<i64>> {",
      "    let h = a.len();",
      "    let w = a[0].len();",
      "    let mut a_t = vec![vec![0; h]; w];",
      "    for hi in 0..h {",
      "        for wi in 0..w {",
      "            a_t[wi][hi] = a[hi][wi];",
      "        }",
      "    }",
      "    a_t",
      "}"
    ]
  },
  "r3yohei_warshall_floyd": {
    "prefix": "r3yohei_warshall_floyd",
    "body": [
      "/// ワーシャルフロイド法",
      "/// 全点対最短経路問題を解くアルゴリズム",
      "/// O(V^3)",
      "/// 制約がN<=10^2くらいのときにエスパー可能",
      "fn warshall_floyd(dist: &mut Vec<Vec<i64>>) {",
      "    let n = dist.len();",
      "    for k in 0..n {",
      "        for i in 0..n {",
      "            for j in 0..n {",
      "                if dist[i][j] > dist[i][k] + dist[k][j] {",
      "                    dist[i][j] = dist[i][k] + dist[k][j];",
      "                }",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  }
}
