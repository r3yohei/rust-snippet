{
  "r3yohei_ChangeMinMax": {
    "prefix": "r3yohei_ChangeMinMax",
    "body": [
      "/// 最小･最大の交換",
      "/// A.chmax(B)のようにすることで，もしA<BならA=Bとしてtrueを返し，そうでなければAのまま保持してfalseを返す",
      "pub trait ChangeMinMax {",
      "    fn chmin(&mut self, x: Self) -> bool;",
      "    fn chmax(&mut self, x: Self) -> bool;",
      "}"
    ]
  },
  "r3yohei_TwoPointer": {
    "prefix": "r3yohei_TwoPointer",
    "body": [
      "/// while1重尺取法",
      "/// https://zenn.dev/luke256/articles/0d60a95fd86ffa",
      "struct TwoPointer<T> {",
      "    n: usize,",
      "    t: T,",
      "}",
      "impl<T> TwoPointer<T> {",
      "    fn new(n: usize, t: T) -> Self {",
      "        Self { n, t }",
      "    }",
      "    fn run(&mut self) {",
      "        let mut l = 0;",
      "        let mut r = 0;",
      "        while l < self.n {",
      "            if r == self.n || todo!(\"条件を満たさない場合を記載\") {",
      "                l += 1;",
      "            } else {",
      "                r += 1;",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "r3yohei_Xoshiro256": {
    "prefix": "r3yohei_Xoshiro256",
    "body": [
      "/// seed値を4つの初期状態値に分割するためのsplit mix 64",
      "struct SplitMix64 {",
      "    s: u64,",
      "}",
      "impl SplitMix64 {",
      "    fn new(seed: u64) -> Self {",
      "        Self { s: seed }",
      "    }",
      "    fn next_u64(&mut self) -> u64 {",
      "        self.s = self.s.wrapping_add(0x9e3779b97f4a7c15);",
      "        let mut z = self.s;",
      "        z = (z ^ z >> 30).wrapping_mul(0xbf58476d1ce4e5b9);",
      "        z = (z ^ z >> 27).wrapping_mul(0x94d049bb133111eb);",
      "        z ^ z >> 31",
      "    }",
      "}",
      "/// Xoshiro256による乱数生成器",
      "struct Xoshiro256 {",
      "    s: [u64; 4],",
      "}",
      "impl Xoshiro256 {",
      "    fn new(seed: u64) -> Self {",
      "        let mut split_mix_64 = SplitMix64::new(seed);",
      "        let mut s = [0; 4];",
      "        for si in &mut s {",
      "            *si = split_mix_64.next_u64();",
      "        }",
      "        Self { s }",
      "    }",
      "    fn next_u64(&mut self) -> u64 {",
      "        let result = (self.s[1].wrapping_mul(5)).rotate_left(7).wrapping_mul(9);",
      "        let t = self.s[1] << 17;",
      "        self.s[2] ^= self.s[0];",
      "        self.s[3] ^= self.s[1];",
      "        self.s[1] ^= self.s[2];",
      "        self.s[0] ^= self.s[3];",
      "        self.s[2] ^= t;",
      "        self.s[3] = self.s[3].rotate_left(45);",
      "        result",
      "    }",
      "    fn gen_usize(&mut self, lower: usize, upper: usize) -> usize {",
      "        assert!(lower < upper);",
      "        let count = upper - lower;",
      "        (self.next_u64() % count as u64) as usize + lower",
      "    }",
      "    fn gen_i64(&mut self, lower: i64, upper: i64) -> i64 {",
      "        assert!(lower < upper);",
      "        let count = upper - lower;",
      "        (self.next_u64() % count as u64) as i64 + lower",
      "    }",
      "    fn gen_f64(&mut self) -> f64 {",
      "        const UPPER_MASK: u64 = 0x3ff0000000000000;",
      "        const LOWER_MASK: u64 = 0xfffffffffffff;",
      "        let result = UPPER_MASK | (self.next_u64() & LOWER_MASK);",
      "        let result: f64 = unsafe { std::mem::transmute(result) };",
      "        result - 1.0",
      "    }",
      "    fn gen_bool(&mut self, prob: f64) -> bool {",
      "        self.gen_f64() < prob",
      "    }",
      "}"
    ]
  },
  "r3yohei_argsort": {
    "prefix": "r3yohei_argsort",
    "body": [
      "/// ベクタのargsort",
      "fn argsort<T: Ord>(v: &[T]) -> Vec<usize> {",
      "    let mut idx = (0..v.len()).collect::<Vec<_>>();",
      "    idx.sort_by(|&i, &j| v[i].cmp(&v[j]));",
      "    idx",
      "}"
    ]
  },
  "r3yohei_bfs": {
    "prefix": "r3yohei_bfs",
    "body": [
      "/// 無向グラフの隣接リスト表現に対するBFS",
      "fn bfs(edges: &Vec<Vec<usize>>, s: usize) {",
      "    let mut deque = VecDeque::new();",
      "    deque.push_back(s);",
      "    let mut dist = vec![-1; edges.len()];",
      "    dist[s] = 0;",
      "    while let Some(crt) = deque.pop_front() {",
      "        for &to in &edges[crt] {",
      "            if dist[to] == -1 {",
      "                dist[to] = dist[crt] + 1;",
      "                deque.push_back(to);",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "r3yohei_bfs_grid": {
    "prefix": "r3yohei_bfs_grid",
    "body": [
      "/// 二次元グリッド上のBFS",
      "fn bfs(c: &Vec<Vec<char>>, s_x: usize, s_y: usize) {",
      "    let h = c.len();",
      "    let w = c[0].len();",
      "    const DIJ: [(usize, usize); 4] = [(1, 0), (0, 1), (!0, 0), (0, !0)];",
      "    let mut deque = VecDeque::new();",
      "    let mut visited = vec![vec![false; w]; h];",
      "    deque.push_back((s_x, s_y));",
      "    visited[s_x][s_y] = true;",
      "    while let Some((crt_x, crt_y)) = deque.pop_front() {",
      "        for i in 0..4 {",
      "            let to_x = crt_x.wrapping_add(DIJ[i].0);",
      "            let to_y = crt_y.wrapping_add(DIJ[i].1);",
      "            if to_x < h && to_y < w {",
      "                if c[to_x][to_y] == '.' && !visited[to_x][to_y] {",
      "                    deque.push_back((to_x, to_y));",
      "                    visited[to_x][to_y] = true;",
      "                }",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "r3yohei_change_radix": {
    "prefix": "r3yohei_change_radix",
    "body": [
      "/// 文字列の数字sをa進数からb進数の文字列に変換する",
      "/// 大きな桁の数字を扱うために文字列としている",
      "pub fn change_radix(s: &str, a: i64, b: i64) -> String {",
      "    let mut base10: i64 = 0;",
      "    for (i, c) in s.chars().rev().enumerate() {",
      "        base10 += c.to_digit(10).unwrap() as i64 * a.pow(i as u32);",
      "    }",
      "    if base10 == 0 {",
      "        return \"0\".to_string();",
      "    }",
      "    let mut result = String::new();",
      "    while base10 != 0 {",
      "        result.push(std::char::from_digit((base10 % b) as u32, 10).unwrap());",
      "        base10 /= b;",
      "    }",
      "    return result.chars().rev().collect::<String>();",
      "}"
    ]
  },
  "r3yohei_dfs": {
    "prefix": "r3yohei_dfs",
    "body": [
      "/// 無向グラフの隣接リスト表現に対するDFS",
      "fn dfs(crt: usize, pre: usize, edges: &Vec<Vec<usize>>, mut visited: &mut Vec<bool>) {",
      "    visited[crt] = true;",
      "    todo!(\"行きがけの処理\");",
      "    for &to in &edges[crt] {",
      "        if visited[to] {",
      "            continue;",
      "        }",
      "        dfs(to, crt, edges, visited);",
      "    }",
      "    todo!(\"帰りがけの処理\");",
      "}"
    ]
  },
  "r3yohei_dfs_grid": {
    "prefix": "r3yohei_dfs_grid",
    "body": [
      "/// 二次元グリッド上のDFS",
      "fn dfs(",
      "    c: &Vec<Vec<char>>,",
      "    crt_x: usize,",
      "    crt_y: usize,",
      "    prev_x: usize,",
      "    prev_y: usize,",
      "    mut visited: &mut Vec<Vec<bool>>,",
      ") {",
      "    const DIJ: [(usize, usize); 4] = [(1, 0), (0, 1), (!0, 0), (0, !0)];",
      "    visited[crt_x][crt_y] = true;",
      "    todo!(\"行きがけの処理\");",
      "    for i in 0..4 {",
      "        let to_x = crt_x.wrapping_add(DIJ[i].0);",
      "        let to_y = crt_y.wrapping_add(DIJ[i].1);",
      "        if to_x < c.len() && to_y < c[0].len() {",
      "            if (to_x == prev_x && to_y == prev_y) || c[to_x][to_y] == '#' || visited[to_x][to_y] {",
      "                continue;",
      "            }",
      "            dfs(c, to_x, to_y, crt_x, crt_y, &mut visited);",
      "        }",
      "    }",
      "    todo!(\"帰りがけの処理\");",
      "}"
    ]
  },
  "r3yohei_dijkstra": {
    "prefix": "r3yohei_dijkstra",
    "body": [
      "/// 無向グラフの隣接リスト表現に対するダイクストラ法",
      "fn dijkstra(edges: &Vec<Vec<(usize, i64)>>, s: usize) -> Vec<i64> {",
      "    let inf = 1_000_000_000;",
      "    let mut dist = vec![inf; edges.len()];",
      "    dist[s] = 0;",
      "    let mut bh = BinaryHeap::new();",
      "    bh.push((Reverse(0), s));",
      "    while let Some((Reverse(dist_crt), crt)) = bh.pop() {",
      "        if dist[crt] < dist_crt {",
      "            continue;",
      "        }",
      "        for &(to, w) in &edges[crt] {",
      "            if dist_crt + w < dist[to] {",
      "                dist[to] = dist[crt] + w;",
      "                bh.push((Reverse(dist[to]), to));",
      "            }",
      "        }",
      "    }",
      "    dist",
      "}"
    ]
  },
  "r3yohei_gaussian_process_regression": {
    "prefix": "r3yohei_gaussian_process_regression",
    "body": [
      "/// ガウス過程回帰のカーネルのハイパーパラメータ",
      "#[derive(Debug, Clone, Copy)]",
      "struct GaussianProcessRegressionParameter {",
      "    theta1: f64,",
      "    theta2: f64,",
      "    theta3: f64,",
      "}",
      "impl GaussianProcessRegressionParameter {",
      "    fn new(theta1: f64, theta2: f64, theta3: f64) -> Self {",
      "        Self {",
      "            theta1,",
      "            theta2,",
      "            theta3,",
      "        }",
      "    }",
      "}",
      "/// 1次元ガウス過程回帰モデル",
      "#[derive(Debug, Clone)]",
      "struct GaussianProcessRegression {",
      "    x: Vec<DVector<f64>>,",
      "    y: Vec<f64>,",
      "    param: GaussianProcessRegressionParameter,",
      "}",
      "impl GaussianProcessRegression {",
      "    pub fn new() -> Self {",
      "        Self {",
      "            x: vec![],",
      "            y: vec![],",
      "            param: GaussianProcessRegressionParameter::new(1.0, 1.0, 0.1),",
      "        }",
      "    }",
      "    pub fn collect_data(&mut self, xi: DVector<f64>, yi: f64) {",
      "        self.x.push(xi);",
      "        self.y.push(yi);",
      "    }",
      "    pub fn predict(&self, x_test: &DMatrix<f64>) -> (Vec<f64>, Vec<f64>) {",
      "        let mut x_train = DMatrix::from_row_slice(",
      "            self.x.len(),",
      "            self.x[0].len(),",
      "            &self.x.iter().flatten().copied().collect_vec(),",
      "        );",
      "        let mut y_train = DVector::from_vec(self.y.clone());",
      "        let y_average = y_train.mean();",
      "        y_train.add_scalar_mut(-y_average);",
      "        let train_len = self.x.len();",
      "        let test_len = x_test.shape().0;",
      "        let mut kernel_mat = self.compute_kernel_matrix(&x_train);",
      "        let kernel_lu = kernel_mat.lu();",
      "        let yy = kernel_lu.solve(&y_train).unwrap();",
      "        let mut mean = vec![];",
      "        let mut covariance = vec![];",
      "        for j in 0..test_len {",
      "            let mut k = vec![];",
      "            for i in 0..train_len {",
      "                let xi = x_train.row(i).transpose();",
      "                let xj = x_test.row(j).transpose();",
      "                let kernel = self.kernel(&xi, &xj, i, j);",
      "                k.push(kernel);",
      "            }",
      "            let k = DVector::from_vec(k);",
      "            let xj = x_test.row(j).transpose();",
      "            let s = self.kernel(&xj, &xj, j + train_len, j + train_len);",
      "            mean.push(k.dot(&yy) + y_average);",
      "            covariance.push(s - (k.transpose() * kernel_lu.solve(&k).unwrap())[(0, 0)]);",
      "        }",
      "        (mean, covariance)",
      "    }",
      "    fn kernel(&self, xi: &DVector<f64>, xj: &DVector<f64>, i: usize, j: usize) -> f64 {",
      "        let diff = xi - xj;",
      "        let norm = diff.component_mul(&diff).sum();",
      "        let mut kernel = self.param.theta1 * (-norm / self.param.theta2.powf(2.0)).exp();",
      "        if i == j {",
      "            kernel += self.param.theta3;",
      "        }",
      "        kernel",
      "    }",
      "    fn compute_kernel_matrix(&self, x_train: &DMatrix<f64>) -> DMatrix<f64> {",
      "        let train_len = x_train.shape().0;",
      "        let mut kernel_mat = DMatrix::zeros(train_len, train_len);",
      "        for i in 0..train_len {",
      "            for j in 0..train_len {",
      "                let xi = x_train.row(i).transpose();",
      "                let xj = x_train.row(j).transpose();",
      "                kernel_mat[(i, j)] = self.kernel(&xi, &xj, i, j);",
      "            }",
      "        }",
      "        kernel_mat",
      "    }",
      "    fn log_likelihood(&self, y_train: &DVector<f64>, kernel_mat: DMatrix<f64>) -> f64 {",
      "        let det = kernel_mat.determinant().max(1e-100);",
      "        -det.ln() - (y_train.transpose() * kernel_mat.lu().solve(&y_train).unwrap())[(0, 0)]",
      "    }",
      "    fn search_ranges(&self) -> (Vec<f64>, Vec<f64>, Vec<f64>) {",
      "        let theta1_range = (3..10).map(|v| 2.0_f64.powi(v)).collect_vec();",
      "        let theta2_range = (2..12).map(|v| 5.0 * v as f64).collect_vec();",
      "        let theta3_range = (0..6).map(|v| 2.0_f64.powi(v)).collect_vec();",
      "        (theta1_range, theta2_range, theta3_range)",
      "    }",
      "    pub fn grid_search(&mut self) {",
      "        let mut x_train = DMatrix::from_row_slice(",
      "            self.x.len(),",
      "            self.x[0].len(),",
      "            &self.x.iter().flatten().copied().collect_vec(),",
      "        );",
      "        let mut y_train = DVector::from_vec(self.y.clone());",
      "        let y_average = y_train.mean();",
      "        y_train.add_scalar_mut(-y_average);",
      "        let train_len = self.x.len();",
      "        let mut best_param = self.param;",
      "        let mut kernel_mat = self.compute_kernel_matrix(&x_train);",
      "        let mut best_likelihood = self.log_likelihood(&y_train, kernel_mat);",
      "        let (theta1_range, theta2_range, theta3_range) = self.search_ranges();",
      "        for &theta1 in &theta1_range {",
      "            for &theta2 in &theta2_range {",
      "                for &theta3 in &theta3_range {",
      "                    self.param = GaussianProcessRegressionParameter::new(theta1, theta2, theta3);",
      "                    let kernel_mat = self.compute_kernel_matrix(&x_train);",
      "                    let likelihood = self.log_likelihood(&y_train, kernel_mat);",
      "                    if best_likelihood < likelihood {",
      "                        best_likelihood = likelihood;",
      "                        best_param =",
      "                            GaussianProcessRegressionParameter::new(theta1, theta2, theta3);",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        self.param = best_param;",
      "    }",
      "}"
    ]
  },
  "r3yohei_get_time": {
    "prefix": "r3yohei_get_time",
    "body": [
      "/// 現在時刻を返す",
      "pub fn get_time() -> f64 {",
      "    static mut STIME: f64 = -1.0;",
      "    let t = std::time::SystemTime::now()",
      "        .duration_since(std::time::UNIX_EPOCH)",
      "        .unwrap();",
      "    let ms = t.as_secs() as f64 + t.subsec_nanos() as f64 * 1e-9;",
      "    unsafe {",
      "        if STIME < 0.0 {",
      "            STIME = ms;",
      "        }",
      "        #[cfg(feature = \"local\")]",
      "        {",
      "            (ms - STIME) * 1.5",
      "        }",
      "        #[cfg(not(feature = \"local\"))]",
      "        {",
      "            ms - STIME",
      "        }",
      "    }",
      "}"
    ]
  },
  "r3yohei_is_ok": {
    "prefix": "r3yohei_is_ok",
    "body": [
      "fn is_ok(mid: i64) -> bool {",
      "    todo!();",
      "}"
    ]
  },
  "r3yohei_is_prime": {
    "prefix": "r3yohei_is_prime",
    "body": [
      "/// 素数判定",
      "/// O(√n)",
      "/// 1~√nまででnを割り切るものがあれば素数でない",
      "fn is_prime(n: usize) -> bool {",
      "    let rootn = (n as f64).sqrt().floor() as usize;",
      "    for i in 2..=rootn {",
      "        if n % i == 0 {",
      "            return false;",
      "        }",
      "    }",
      "    true",
      "}"
    ]
  },
  "r3yohei_lis": {
    "prefix": "r3yohei_lis",
    "body": [
      "/// 最長部分増加列(LIS)を求める O(NlogN)",
      "/// https://qiita.com/python_walker/items/d1e2be789f6e7a0851e5",
      "fn lis(a: &[i64]) -> usize {",
      "    let inf: i64 = 1_000_000_000;",
      "    let mut dp = vec![inf; a.len()];",
      "    let mut p = vec![0; a.len()];",
      "    for (i, &ai) in a.iter().enumerate() {",
      "        let j = dp.lower_bound(&ai);",
      "        dp[j] = ai;",
      "        p[i] = j + 1;",
      "    }",
      "    let mut ans = 0;",
      "    for i in 0..a.len() {",
      "        if dp[i] != inf {",
      "            ans += 1;",
      "        }",
      "    }",
      "    ans",
      "}"
    ]
  },
  "r3yohei_meguru_bisect": {
    "prefix": "r3yohei_meguru_bisect",
    "body": [
      "fn is_ok(mid: i64) -> bool {",
      "    todo!();",
      "}",
      "/// めぐる式二分探索(https://aotamasaki.hatenablog.com/entry/meguru_bisect)",
      "/// ng: '取り得る最小の値' - 1",
      "/// ok: '取り得る最大の値' + 1",
      "fn meguru_bisect(mut ng: i64, mut ok: i64) -> i64 {",
      "    while (ok - ng).abs() > 1 {",
      "        let mid = (ok + ng) / 2;",
      "        if is_ok(mid) {",
      "            ok = mid;",
      "        } else {",
      "            ng = mid;",
      "        }",
      "    }",
      "    ok",
      "}"
    ]
  },
  "r3yohei_memorization_recursion": {
    "prefix": "r3yohei_memorization_recursion",
    "body": [
      "/// メモ化再帰関数",
      "/// 例: フィボナッチ数列",
      "pub fn memo_rec(n: i64, mut memo: &mut HashMap<i64, i64>) -> i64 {",
      "    return match memo.get(&n) {",
      "        None => {",
      "            let new = memo_rec(n - 2, memo) + memo_rec(n - 1, memo);",
      "            memo.insert(n, new);",
      "            new",
      "        }",
      "        _ => memo[&n],",
      "    };",
      "}"
    ]
  },
  "r3yohei_modinv": {
    "prefix": "r3yohei_modinv",
    "body": [
      "/// x^p mod MODを繰り返し二乗法により求める",
      "/// O(log(p))",
      "fn modpow(mut x: i64, mut p: i64, mod_num: i64) -> i64 {",
      "    let mut ret = 1;",
      "    while p > 0 {",
      "        if p & 1 == 1 {",
      "            ret *= x;",
      "            ret %= mod_num;",
      "        }",
      "        x *= x;",
      "        x %= mod_num;",
      "        p >>= 1;",
      "    }",
      "    ret",
      "}",
      "/// MODを法とするxの逆元を見つける",
      "fn modinv(x: i64, mod_num: i64) -> i64 {",
      "    modpow(x, mod_num - 2, mod_num)",
      "}"
    ]
  },
  "r3yohei_modpow": {
    "prefix": "r3yohei_modpow",
    "body": [
      "/// x^p mod MODを繰り返し二乗法により求める",
      "/// O(log(p))",
      "fn modpow(mut x: i64, mut p: i64, mod_num: i64) -> i64 {",
      "    let mut ret = 1;",
      "    while p > 0 {",
      "        if p & 1 == 1 {",
      "            ret *= x;",
      "            ret %= mod_num;",
      "        }",
      "        x *= x;",
      "        x %= mod_num;",
      "        p >>= 1;",
      "    }",
      "    ret",
      "}"
    ]
  },
  "r3yohei_prim": {
    "prefix": "r3yohei_prim",
    "body": [
      "/// プリム法により最小全域木のコストを返す",
      "/// O(N + MlogN)",
      "pub fn prim(edges: &Vec<Vec<(usize, i64)>>) -> i64 {",
      "    let mut cost = 0;",
      "    let mut visited = vec![false; edges.len()];",
      "    let mut bh = BinaryHeap::new();",
      "    bh.push((Reverse(0), 0, !0));",
      "    while let Some((Reverse(w1), crt, frm)) = bh.pop() {",
      "        if visited[crt] {",
      "            continue;",
      "        }",
      "        visited[crt] = true;",
      "        if frm != !0 {",
      "            cost += w1;",
      "        }",
      "        for &(to, w2) in &edges[crt] {",
      "            if visited[to] {",
      "                continue;",
      "            }",
      "            bh.push((Reverse(w2), to, crt));",
      "        }",
      "    }",
      "    cost",
      "}"
    ]
  },
  "r3yohei_prime_factorization": {
    "prefix": "r3yohei_prime_factorization",
    "body": [
      "/// 素数判定",
      "/// O(√n)",
      "/// 1~√nまででnを割り切るものがあれば素数でない",
      "fn is_prime(n: usize) -> bool {",
      "    let rootn = (n as f64).sqrt().floor() as usize;",
      "    for i in 2..=rootn {",
      "        if n % i == 0 {",
      "            return false;",
      "        }",
      "    }",
      "    true",
      "}",
      "/// 素因数分解",
      "/// is_prime()に依存",
      "fn prime_factorization(mut n: usize) -> Vec<usize> {",
      "    let mut factor = vec![];",
      "    if is_prime(n) {",
      "        factor.push(n);",
      "        factor",
      "    } else {",
      "        let rootn = (n as f64).sqrt().floor() as usize;",
      "        for i in 2..=rootn {",
      "            while n % i == 0 {",
      "                n /= i;",
      "                factor.push(i);",
      "            }",
      "        }",
      "        if n != 1 {",
      "            factor.push(n);",
      "        }",
      "        factor",
      "    }",
      "}"
    ]
  },
  "r3yohei_run_length_encoding": {
    "prefix": "r3yohei_run_length_encoding",
    "body": [
      "/// ランレングス符号化",
      "/// s = \"RRRLLRLRRLLLLRLRR\"などを",
      "/// [(R, 3), (L, 2), (R, 1), (L, 1), (R, 2), (L, 4), (R, 1), (L, 1), (R, 2)]",
      "/// のように変換する",
      "/// O(n)",
      "fn run_length_encoding(s: Vec<i64>) -> Vec<(i64, usize)> {",
      "    let mut tmp = s[0];",
      "    let mut cnt = 0;",
      "    let mut encode = vec![];",
      "    for &si in &s {",
      "        if tmp == si {",
      "            cnt += 1;",
      "        } else {",
      "            encode.push((tmp, cnt));",
      "            tmp = si;",
      "            cnt = 1;",
      "        }",
      "    }",
      "    encode.push((tmp, cnt));",
      "    encode",
      "}"
    ]
  },
  "r3yohei_sieve_of_eratosthenes": {
    "prefix": "r3yohei_sieve_of_eratosthenes",
    "body": [
      "/// エラトステネスの篩",
      "/// n以下の素数を列挙する",
      "/// O(nloglogn)",
      "fn sieve_of_eratosthenes(n: usize) -> Vec<usize> {",
      "    let mut is_prime = vec![true; n + 1];",
      "    let mut prime = vec![];",
      "    for i in 2..(n as usize + 1) {",
      "        if is_prime[i] {",
      "            prime.push(i);",
      "            for j in (i * 2..n + 1).step_by(i) {",
      "                is_prime[j] = false;",
      "            }",
      "        }",
      "    }",
      "    prime",
      "}"
    ]
  },
  "r3yohei_sieve_of_eratosthenes_from_l_to_r": {
    "prefix": "r3yohei_sieve_of_eratosthenes_from_l_to_r",
    "body": [
      "/// L以上R以下の素数のエラトステネスの篩による列挙",
      "/// is_prime[x]: x+Lが素数かどうか",
      "fn sieve_of_eratosthenes_from_l_to_r(n: usize, l: usize, r: usize) -> Vec<usize> {",
      "    let mut is_prime = vec![true; r - l + 1];",
      "    if l == 1 {",
      "        is_prime[0] = false;",
      "    }",
      "    let rootn = (n as f64).sqrt().floor() as usize;",
      "    for i in 2..=rootn {",
      "        let min_value = ((l + i - 1) / i) * i;",
      "        for j in (min_value..=r).step_by(i) {",
      "            if j == i {",
      "                continue;",
      "            }",
      "            is_prime[j - l] = false;",
      "        }",
      "    }",
      "    let mut prime = vec![];",
      "    for i in 0..r - l + 1 {",
      "        if is_prime[i] {",
      "            prime.push(i + l);",
      "        }",
      "    }",
      "    prime",
      "}"
    ]
  },
  "r3yohei_sinkhorn_knopp": {
    "prefix": "r3yohei_sinkhorn_knopp",
    "body": [
      "/// Sinkhorn-Knoppアルゴリズム",
      "/// [つるさんのブログ](https://theory-and-me.hatenablog.com/entry/2021/05/09/181435)",
      "fn sinkhorn_knopp(",
      "    a: Vec<f64>,",
      "    b: Vec<f64>,",
      "    C: Vec<Vec<f64>>,",
      "    lambda: f64,",
      "    tolerance: f64,",
      ") -> Vec<Vec<f64>> {",
      "    //! N件のソースからM件のターゲットにいくらかモノを運ぶ",
      "    //! 各ソースsiにはai個の供給があり，各ターゲットtiにはbi個の需要がある",
      "    //! Σ(1~n)ai = Σ(1~M)biとする",
      "    //! si->tj にモノを運ぶのに，cijの輸送コストがかかる",
      "    //! si->tjへの輸送量xijを適切に決めて，各ターゲットの要求を満たしつつ輸送コストの和を最小化する",
      "    //!",
      "    //! Args:",
      "    //!     a: ソースの供給量ベクタ",
      "    //!     b: ターゲットの需要量ベクタ",
      "    //!     C: ソースiからターゲットjへの輸送コストcijの行列",
      "    //!     lambda: Sinkhorn-Knoppアルゴリズムの性能をコントロールするハイパーパラメータ (>0)",
      "    //!             大きいほど真の値に近づくが，収束が遅くなる",
      "    //!             ただし，あまりに大きい値にするとexp(-λ*cij)が破綻する",
      "    //!     tolerance: ベクタu, vのノルムがこれより変化しなくなったら収束したとみなす",
      "    //! Returns:",
      "    //!     R: ソースiからターゲットjへの輸送量rijの行列",
      "    let K = DMatrix::from_row_slice(",
      "        C.len(),",
      "        C[0].len(),",
      "        &C.iter()",
      "            .flatten()",
      "            .map(|&cij| f64::exp(-lambda * cij))",
      "            .collect_vec(),",
      "    );",
      "    let K_t = K.transpose();",
      "    let a = DVector::from_vec(a);",
      "    let b = DVector::from_vec(b);",
      "    let mut u = DVector::from_element(C.len(), 1.0);",
      "    let mut v = b.component_div(&(&K_t * &u));",
      "    let mut iter = 0;",
      "    loop {",
      "        iter += 1;",
      "        let next_u = a.component_div(&(&K * &v));",
      "        let next_v = b.component_div(&(&K_t * &u));",
      "        let error = (&next_u - &u).norm() + (&next_v - &v).norm();",
      "        if error < tolerance {",
      "            eprintln!(\"sinkhorn-knopp is converged after {} iterations\", iter);",
      "            break;",
      "        }",
      "        u = next_u;",
      "        v = next_v;",
      "    }",
      "    let U = DMatrix::from_diagonal(&u);",
      "    let V = DMatrix::from_diagonal(&v);",
      "    let R = U * K * V;",
      "    let R: Vec<Vec<f64>> = R.row_iter().map(|r| r.iter().copied().collect()).collect();",
      "    R",
      "}"
    ]
  },
  "r3yohei_split_mix_64": {
    "prefix": "r3yohei_split_mix_64",
    "body": [
      "/// seed値を4つの初期状態値に分割するためのsplit mix 64",
      "struct SplitMix64 {",
      "    s: u64,",
      "}",
      "impl SplitMix64 {",
      "    fn new(seed: u64) -> Self {",
      "        Self { s: seed }",
      "    }",
      "    fn next_u64(&mut self) -> u64 {",
      "        self.s = self.s.wrapping_add(0x9e3779b97f4a7c15);",
      "        let mut z = self.s;",
      "        z = (z ^ z >> 30).wrapping_mul(0xbf58476d1ce4e5b9);",
      "        z = (z ^ z >> 27).wrapping_mul(0x94d049bb133111eb);",
      "        z ^ z >> 31",
      "    }",
      "}"
    ]
  },
  "r3yohei_transpose": {
    "prefix": "r3yohei_transpose",
    "body": [
      "/// 二次元配列の転置を求める",
      "fn transpose(a: &Vec<Vec<i64>>) -> Vec<Vec<i64>> {",
      "    let h = a.len();",
      "    let w = a[0].len();",
      "    let mut a_t = vec![vec![0; h]; w];",
      "    for hi in 0..h {",
      "        for wi in 0..w {",
      "            a_t[wi][hi] = a[hi][wi];",
      "        }",
      "    }",
      "    a_t",
      "}"
    ]
  },
  "r3yohei_warshall_floyd": {
    "prefix": "r3yohei_warshall_floyd",
    "body": [
      "/// ワーシャルフロイド法",
      "/// 全点対最短経路問題を解くアルゴリズム",
      "/// O(V^3)",
      "/// 制約がN<=10^2くらいのときにエスパー可能",
      "fn warshall_floyd(dist: &mut Vec<Vec<i64>>) {",
      "    let n = dist.len();",
      "    for k in 0..n {",
      "        for i in 0..n {",
      "            for j in 0..n {",
      "                if dist[i][j] > dist[i][k] + dist[k][j] {",
      "                    dist[i][j] = dist[i][k] + dist[k][j];",
      "                }",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  }
}
